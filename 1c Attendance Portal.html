<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Control Systems: PZ Interactive Response</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>

  <style>
    :root {
      --bg: #000000;
      --panel-bg: #101214;
      --panel-bg2: #15181b;
      --text: #f9fafb;
      --muted: #9ca3af;
      --border: rgba(255,255,255,0.15);
      --highlight: #38bdf8;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .app {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .left {
      flex: 1 1 auto;
      padding-left: 20px;
      padding-right: 16px;
      padding-bottom: 20px;
      padding-top: 20px;
      overflow: auto;
    }

    .right {
      flex: 0 0 300px;
      width: 300px;
      background: linear-gradient(180deg, var(--panel-bg) 0%, var(--panel-bg2) 100%);
      border-left: 1px solid var(--border);
      padding: 14px;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .plot-group {
      margin-bottom: 4px;
    }

    /* Response plot group with fixed height to keep PZ position fixed and reduce gap */
    .plot-group.response-group {
      height: 260px; /* slightly tighter */
    }

    .plot-wrapper {
      background: #000;
      border-radius: 8px;
      width: 600px;
      overflow: hidden;
    }

    .plot-wrapper canvas {
      display: block;
      width: 600px;
      height: 260px;
    }

    .pz-wrapper {
      background: #000;
      border-radius: 8px;
      width: 600px;
      overflow: hidden;
      margin-top: 4px;
    }

    .pz-wrapper canvas {
      display: block;
      width: 600px;
      height: 260px;
    }

    h2 {
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: 700;
    }

    .section-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin: 8px 0 4px 0;
    }

    label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 3px;
    }

    input[type="number"], input[type="text"], select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.4);
      color: var(--text);
      font-size: 13px;
      outline: none;
    }
    input[type="number"]:focus,
    input[type="text"]:focus,
    select:focus {
      border-color: var(--highlight);
      box-shadow: 0 0 0 2px rgba(56,189,248,0.4);
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 4px;
    }

    .row-3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      margin-bottom: 4px;
    }

    .radio-row, .check-row {
      display: flex;
      gap: 10px;
      font-size: 12px;
      color: var(--text);
      margin-bottom: 4px;
      flex-wrap: wrap;
    }
    .radio-row label, .check-row label { margin: 0; }

    input[type="radio"], input[type="checkbox"] {
      accent-color: var(--highlight);
    }

    .btn-row {
      display: flex;
      gap: 6px;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    button {
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-size: 12px;
      padding: 6px 10px;
      cursor: pointer;
      font-weight: 600;
    }

    button.primary {
      border-color: rgba(56,189,248,0.7);
      background: rgba(56,189,248,0.18);
    }

    button:hover {
      background: rgba(255,255,255,0.12);
    }

    button.primary:hover {
      background: rgba(56,189,248,0.26);
    }

    .status {
      font-size: 11px;
      color: var(--muted);
      margin-top: 6px;
    }
    .status span.ok { color: #a7f3d0; }
    .status span.warn { color: #fde68a; }
    .status span.err { color: #fecaca; }

    @media (max-width: 900px) {
      .app {
        flex-direction: column;
      }
      .right {
        flex: 0 0 auto;
        width: 100%;
        max-height: 50vh;
      }
      .plot-wrapper,
      .plot-wrapper canvas,
      .pz-wrapper,
      .pz-wrapper canvas {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div class="app">
  <div class="left">
    <!-- Response plot group: fixed-height spacer -->
    <div class="plot-group response-group">
      <div class="plot-wrapper" id="responseWrapper">
        <canvas id="responseCanvas"></canvas>
      </div>
    </div>

    <!-- Pole-zero plot (must not move) -->
    <div class="plot-group">
      <div class="pz-wrapper">
        <canvas id="pzCanvas"></canvas>
      </div>
    </div>
  </div>

  <div class="right">
    <!-- Input type -->
    <div class="radio-row">
      <label>
        <input type="radio" name="inputType" value="step" checked>
        Step
      </label>
      <label>
        <input type="radio" name="inputType" value="impulse">
        Impulse (approx.)
      </label>
    </div>

    <!-- Visibility controls (1: axis+curve, 2: curve, 3: final value) -->
    <div class="check-row">
      <label>
        <input type="checkbox" id="showResponsePlot">
        Show response plot (axis + curve)
      </label>
    </div>
    <div class="check-row">
      <label>
        <input type="checkbox" id="showResponseCurve" checked>
        Show response curve C(t)
      </label>
    </div>
    <div class="check-row">
      <label>
        <input type="checkbox" id="showFinalValue">
        Show final value on response plot
      </label>
    </div>

    <!-- Time axis + Gain row: tMax | dt | K -->
    <div class="section-title">Time axis & gain</div>
    <div class="row-3">
      <div>
        <label for="tMax">tMax (s)</label>
        <input id="tMax" type="number" step="5" min="0.1" value="10.1">
      </div>
      <div>
        <label for="dt">dt (s)</label>
        <input id="dt" type="number" step="0.001" min="0.0005" value="0.01">
      </div>
      <div>
        <label for="gainK">Gain K</label>
        <input id="gainK" type="number" step="0.1" value="1">
      </div>
    </div>

    <!-- System definition -->
    <label for="zerosInput" style="margin-top:6px;">Zeros (comma-separated, Im ≥ 0 only)</label>
    <input id="zerosInput" type="text" placeholder="-0.5+1j">

    <label for="polesInput" style="margin-top:6px;">Poles (comma-separated, Im ≥ 0 only)</label>
    <input id="polesInput" type="text" placeholder="-0.5+1j">

    <div style="margin-top:6px;">Canvas add mode:</div>
    <div class="radio-row">
      <label>
        <input type="radio" name="addType" value="zero">
        Zero
      </label>
      <label>
        <input type="radio" name="addType" value="pole" checked>
        Pole
      </label>
    </div>

    <div class="btn-row">
      <button id="addAtCenter" type="button">Add at center</button>
      <button id="resetSystem" type="button">Reset system</button>
    </div>

    <!-- PZ axis limits -->
    <div class="section-title">PZ axis limits</div>
    <div class="row">
      <div>
        <label for="reMin">Re(s) min</label>
        <input id="reMin" type="number" step="0.5" value="-5">
      </div>
      <div>
        <label for="reMax">Re(s) max</label>
        <input id="reMax" type="number" step="0.5" value="2">
      </div>
    </div>
    <div class="row">
      <div>
        <label for="imMax">|Im(s)| max</label>
        <input id="imMax" type="number" step="0.5" value="3">
      </div>
      <div>
        <label>Im(s) min</label>
        <input type="text" id="imMinDisplay" disabled value="-3">
      </div>
    </div>

    <!-- Interaction help -->
    <div class="section-title">PZ interaction</div>
    <div class="status">
      • Click near real axis (±10px) to add real pole/zero.<br>
      • Else, adds conjugate pair (Im ±b) automatically.<br>
      • Drag a point to move it (real stays on real axis).<br>
      • Double-click element to delete it.
    </div>

    <!-- Status -->
    <div class="section-title">Simulation status</div>
    <div class="status" id="simStatus"></div>
  </div>
</div>

<script>
/* ============================
   Utility / Math helpers
   ============================ */

function isFiniteNumber(x) {
  return typeof x === "number" && Number.isFinite(x);
}
function fmt(x, d = 4) {
  if (!isFiniteNumber(x)) return "NaN";
  const abs = Math.abs(x);
  if (abs !== 0 && (abs < 1e-3 || abs > 1e4)) return x.toExponential(3);
  return Number(x.toFixed(d)).toString();
}

/* Polynomial from complex roots with conjugate handling */

function polyFromRoots(roots) {
  let coef = [1];
  const used = new Array(roots.length).fill(false);

  for (let i = 0; i < roots.length; i++) {
    if (used[i]) continue;
    const r = roots[i];
    if (Math.abs(r.im) < 1e-8) {
      const newCoef = new Array(coef.length + 1).fill(0);
      for (let k = 0; k < coef.length; k++) {
        newCoef[k]     -= coef[k] * r.re;
        newCoef[k + 1] += coef[k];
      }
      coef = newCoef;
      used[i] = true;
    } else {
      let jConj = -1;
      for (let j = i + 1; j < roots.length; j++) {
        if (used[j]) continue;
        const r2 = roots[j];
        if (Math.abs(r2.re - r.re) < 1e-6 &&
            Math.abs(r2.im + r.im) < 1e-6) {
          jConj = j;
          break;
        }
      }
      const a = r.re, b = r.im;
      const q = [a*a + b*b, -2*a, 1];
      const newCoef = new Array(coef.length + 2).fill(0);
      for (let k = 0; k < coef.length; k++) {
        for (let m = 0; m < q.length; m++) {
          newCoef[k + m] += coef[k] * q[m];
        }
      }
      coef = newCoef;
      used[i] = true;
      if (jConj >= 0) used[jConj] = true;
    }
  }
  return coef;
}

function buildTransferFunction(zeros, poles, K) {
  const num = polyFromRoots(zeros);
  const den = polyFromRoots(poles);
  while (den.length <= num.length) den.unshift(0);
  const numK = num.map(c => c * K);
  return { num: numK, den };
}

function tfToStateSpace(num, den) {
  const n = den.length - 1;
  if (n <= 0) return { A: [[0]], B: [[0]], C: [[0]], D: [[0]] };

  const alpha = den[n];
  const a = den.map(c => c / alpha);
  const b = num.map(c => c / alpha);

  const bPad = new Array(den.length).fill(0);
  for (let i = 0; i < num.length; i++) bPad[i] = b[i];

  const A = Array.from({length: n}, () => Array(n).fill(0));
  for (let i = 0; i < n - 1; i++) A[i][i+1] = 1;
  for (let j = 0; j < n; j++) A[n-1][j] = -a[j];

  const B = Array(n).fill(0); B[n-1] = 1;
  const C = Array(n).fill(0);
  for (let i = 0; i < n; i++) C[i] = bPad[i] - a[i] * bPad[n];
  const D = bPad[n];

  return {
    A,
    B: B.map(x => [x]),
    C: [C],
    D: [[D]]
  };
}

function simulateSystem(ss, tMax, dt, inputType) {
  const { A, B, C, D } = ss;
  const n = A.length;
  const steps = Math.max(2, Math.floor(tMax / dt) + 1);
  const t = new Float64Array(steps);
  const y = new Float64Array(steps);
  const r = new Float64Array(steps);

  for (let k = 0; k < steps; k++) {
    t[k] = k * dt;
    r[k] = (inputType === "step") ? 1 : (k === 0 ? 1/dt : 0);
  }

  const x = new Float64Array(n);

  function Ax_plus_Bu(xVec, u) {
    const dx = new Float64Array(n);
    for (let i = 0; i < n; i++) {
      let s = 0;
      for (let j = 0; j < n; j++) s += A[i][j] * xVec[j];
      dx[i] = s + B[i][0] * u;
    }
    return dx;
  }

  for (let k = 0; k < steps; k++) {
    const u = r[k];
    let yk = 0;
    for (let i = 0; i < n; i++) yk += C[0][i] * x[i];
    yk += D[0][0] * u;
    y[k] = yk;

    if (k < steps - 1) {
      const k1 = Ax_plus_Bu(x, u);
      const x2 = new Float64Array(n);
      for (let i = 0; i < n; i++) x2[i] = x[i] + 0.5*dt*k1[i];

      const k2 = Ax_plus_Bu(x2, u);
      const x3 = new Float64Array(n);
      for (let i = 0; i < n; i++) x3[i] = x[i] + 0.5*dt*k2[i];

      const k3 = Ax_plus_Bu(x3, u);
      const x4 = new Float64Array(n);
      for (let i = 0; i < n; i++) x4[i] = x[i] + dt*k3[i];

      const k4 = Ax_plus_Bu(x4, u);
      for (let i = 0; i < n; i++) {
        x[i] += dt*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i])/6;
      }
    }
  }

  return { t, y, r };
}

function computeMinMax(arr) {
  let min = Infinity, max = -Infinity;
  for (let v of arr) {
    if (!isFiniteNumber(v)) continue;
    if (v < min) min = v;
    if (v > max) max = v;
  }
  if (min === Infinity) return {min: -1, max: 1};
  if (Math.abs(max - min) < 1e-9) {
    const pad = (Math.abs(min) + 1)*0.5;
    return {min: min - pad, max: max + pad};
  }
  return {min, max};
}

/* ============================
   State
   ============================ */

const state = {
  inputType: "step",
  tMax: 10,
  dt: 0.01,
  K: 1,
  zeros: [],
  poles: [],
  showFinalValue: false,
  showResponsePlot: false,   // default unchecked
  showResponseCurve: true,
  pzAxis: { reMin: -5, reMax: 1, imMax: 3 },
};

/* Default system */
function resetSystem() {
  state.K = 1;
  state.zeros = [];
  state.poles = [
    { re: -0.5, im: 1 },
    { re: -0.5, im: -1 }
  ];
}

/* ============================
   DOM
   ============================ */

const responseWrapper = document.getElementById("responseWrapper");
const responseCanvas  = document.getElementById("responseCanvas");
const pzCanvas        = document.getElementById("pzCanvas");

const tMaxInput = document.getElementById("tMax");
const dtInput   = document.getElementById("dt");
const gainInput = document.getElementById("gainK");
const simStatus = document.getElementById("simStatus");

const inputTypeRadios = document.querySelectorAll("input[name='inputType']");
const addTypeRadios   = document.querySelectorAll("input[name='addType']");
const addAtCenterBtn  = document.getElementById("addAtCenter");
const resetSystemBtn  = document.getElementById("resetSystem");
const showFinalValueCheckbox    = document.getElementById("showFinalValue");
const showResponsePlotCheckbox  = document.getElementById("showResponsePlot");
const showResponseCurveCheckbox = document.getElementById("showResponseCurve");

const zerosInput = document.getElementById("zerosInput");
const polesInput = document.getElementById("polesInput");

const reMinInput = document.getElementById("reMin");
const reMaxInput = document.getElementById("reMax");
const imMaxInput = document.getElementById("imMax");
const imMinDisplay = document.getElementById("imMinDisplay");

function setupCanvas(c, cssWidth, cssHeight) {
  const dpr = window.devicePixelRatio || 1;
  c.width = cssWidth * dpr;
  c.height = cssHeight * dpr;
}

/* ============================
   Plotting
   ============================ */

function plotResponseWithInput(canvas, t, y, r, tMax, yMin, yMax, options) {
  const { showFinal, finalValue, showCurve } = options || {};
  const ctx = canvas.getContext("2d");
  const dpr = window.devicePixelRatio || 1;
  const W = canvas.width;
  const H = canvas.height;

  ctx.save();
  ctx.scale(dpr, dpr);

  const w = W / dpr;
  const h = H / dpr;

  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, w, h);

  const padL = 50, padR = 10, padT = 10, padB = 28;
  const x0 = padL, x1 = w - padR;
  const y0 = padT, y1 = h - padB;

  // grid
  ctx.strokeStyle = "rgba(255,255,255,0.15)";
  ctx.lineWidth = 1;
  const gx = 10, gy = 6;
  for (let i = 0; i <= gx; i++) {
    const x = x0 + (x1 - x0)*(i/gx);
    ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke();
  }
  for (let j = 0; j <= gy; j++) {
    const yy = y0 + (y1 - y0)*(j/gy);
    ctx.beginPath(); ctx.moveTo(x0,yy); ctx.lineTo(x1,yy); ctx.stroke();
  }

  // axes
  ctx.strokeStyle = "rgba(255,255,255,0.9)";
  ctx.lineWidth = 1.5;
  const yZeroFrac = (0 - yMin)/(yMax - yMin);
  const yZeroPix  = y1 - (y1 - y0)*yZeroFrac;
  const xAxisY    = (yZeroPix >= y0 && yZeroPix <= y1) ? yZeroPix : y1;

  ctx.beginPath(); ctx.moveTo(x0, xAxisY); ctx.lineTo(x1, xAxisY); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x0, y0);     ctx.lineTo(x0, y1);     ctx.stroke();

  // Show zero marking on response x-axis at t = 0
  const zeroX = x0;
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.beginPath();
  ctx.moveTo(zeroX, xAxisY - 4);
  ctx.lineTo(zeroX, xAxisY + 4);
  ctx.stroke();

  // ticks
  ctx.fillStyle = "rgba(255,255,255,0.8)";
  ctx.font = "11px system-ui";
  ctx.textBaseline = "middle";

  const yLabCount = 4;
  for (let i = 0; i <= yLabCount; i++) {
    const frac = i / yLabCount;
    const v = yMax - (yMax - yMin)*frac;
    const yy = y0 + (y1 - y0)*frac;
    ctx.textAlign = "right";
    ctx.fillText(fmt(v,3), x0 - 4, yy);
  }

  const xLabCount = 6;
  ctx.textBaseline = "top";
  for (let i = 0; i <= xLabCount; i++) {
    const frac = i / xLabCount;
    const tt = tMax*frac;
    const xx = x0 + (x1 - x0)*frac;
    ctx.textAlign = "center";
    ctx.fillText(fmt(tt,3), xx, y1 + 2);
  }

  const N = Math.min(t.length, y.length);

  // Response C(t) in magenta (if enabled)
  if (showCurve) {
    ctx.strokeStyle = "rgba(236,72,153,1)";
    ctx.lineWidth   = 1.8;
    ctx.beginPath();
    for (let i = 0; i < N; i++) {
      const xx = x0 + (x1 - x0)*(t[i]/tMax);
      const yy = y1 - (y1 - y0)*((y[i]-yMin)/(yMax-yMin));
      if (i === 0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
    }
    ctx.stroke();
  }

  // Optional final value line (green dotted)
  if (showFinal && isFiniteNumber(finalValue)) {
    const frac = (finalValue - yMin)/(yMax - yMin);
    const fy = y1 - (y1 - y0)*frac;
    ctx.strokeStyle = "rgba(34,197,94,1)";
    ctx.lineWidth = 1.5;
    if (ctx.setLineDash) ctx.setLineDash([6,4]);
    ctx.beginPath();
    ctx.moveTo(x0, fy);
    ctx.lineTo(x1, fy);
    ctx.stroke();
    if (ctx.setLineDash) ctx.setLineDash([]);
  }

  // labels
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.textAlign = "right";
  ctx.textBaseline = "bottom";
  ctx.fillText("t (s)", x1, y1 - 2);

  ctx.save();
  ctx.translate(12, (y0 + y1)/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText("Response C(t)", 0, -5);
  ctx.restore();

  ctx.restore();
}

/* PZ config and drawing */

const pzConfig = {
  get reMin() { return state.pzAxis.reMin; },
  get reMax() { return state.pzAxis.reMax; },
  get imMin() { return -state.pzAxis.imMax; },
  get imMax() { return state.pzAxis.imMax; },
  radius: 8,
};

function pzToCanvas(x, y) {
  const dpr = window.devicePixelRatio || 1;
  const W = pzCanvas.width / dpr;
  const H = pzCanvas.height / dpr;
  const padL = 40, padR = 10, padT = 10, padB = 30;
  const x0 = padL, x1 = W - padR;
  const y0 = padT, y1 = H - padB;

  const xr = (x - pzConfig.reMin)/(pzConfig.reMax - pzConfig.reMin);
  const yr = (y - pzConfig.imMin)/(pzConfig.imMax - pzConfig.imMin);
  return { px: x0 + xr*(x1 - x0), py: y1 - yr*(y1 - y0) };
}

function canvasToPZ(px, py) {
  const dpr = window.devicePixelRatio || 1;
  const W = pzCanvas.width / dpr;
  const H = pzCanvas.height / dpr;
  const padL = 40, padR = 10, padT = 10, padB = 30;
  const x0 = padL, x1 = W - padR;
  const y0 = padT, y1 = H - padB;

  const xr = (px - x0)/(x1 - x0);
  const yr = (y1 - py)/(y1 - y0);

  const re = pzConfig.reMin + xr*(pzConfig.reMax - pzConfig.reMin);
  const im = pzConfig.imMin + yr*(pzConfig.imMax - pzConfig.imMin);
  return { re, im };
}

function drawPZ() {
  const ctx = pzCanvas.getContext("2d");
  const dpr = window.devicePixelRatio || 1;
  const W = pzCanvas.width;
  const H = pzCanvas.height;

  ctx.save();
  ctx.scale(dpr, dpr);
  const w = W / dpr;
  const h = H / dpr;

  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, w, h);

  const padL = 40, padR = 10, padT = 10, padB = 30;
  const x0 = padL, x1 = w - padR;
  const y0 = padT, y1 = h - padB;

  // integer grid
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = 1;

  const reMin = Math.ceil(pzConfig.reMin);
  const reMax = Math.floor(pzConfig.reMax);
  for (let xv = reMin; xv <= reMax; xv++) {
    const { px } = pzToCanvas(xv, 0);
    ctx.beginPath(); ctx.moveTo(px, y0); ctx.lineTo(px, y1); ctx.stroke();
  }

  const imMin = Math.ceil(pzConfig.imMin);
  const imMax = Math.floor(pzConfig.imMax);
  for (let yv = imMin; yv <= imMax; yv++) {
    const { py } = pzToCanvas(0, yv);
    ctx.beginPath(); ctx.moveTo(x0, py); ctx.lineTo(x1, py); ctx.stroke();
  }

  // axes
  ctx.strokeStyle = "rgba(255,255,255,0.9)";
  ctx.lineWidth = 1.5;
  const zeroReFrac = (0 - pzConfig.reMin)/(pzConfig.reMax - pzConfig.reMin);
  const zeroReX = x0 + zeroReFrac*(x1 - x0);
  ctx.beginPath(); ctx.moveTo(zeroReX,y0); ctx.lineTo(zeroReX,y1); ctx.stroke();

  const zeroImFrac = (0 - pzConfig.imMin)/(pzConfig.imMax - pzConfig.imMin);
  const zeroImY = y1 - zeroImFrac*(y1 - y0);
  ctx.beginPath(); ctx.moveTo(x0,zeroImY); ctx.lineTo(x1,zeroImY); ctx.stroke();

  // integer tick labels
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "11px system-ui";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  for (let xv = reMin; xv <= reMax; xv++) {
    const { px } = pzToCanvas(xv, 0);
    ctx.fillText(xv.toString(), px, y1 + 2);
  }

  ctx.textBaseline = "middle";
  ctx.textAlign = "right";
  for (let yv = imMin; yv <= imMax; yv++) {
    const { py } = pzToCanvas(0, yv);
    ctx.fillText(yv.toString(), x0 - 4, py);
  }

  // labels
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText("Re(s)", (x0 + x1)/1.5+150, y1/2+12);
  ctx.save();
  ctx.translate(12, (y0 + y1)/2);
  ctx.rotate(-Math.PI/2);
  ctx.textBaseline = "top";
  ctx.fillText("Im(s)", 0, 0);
  ctx.restore();

  // zeros
  for (const z of state.zeros) {
    const {px,py} = pzToCanvas(z.re,z.im);
    ctx.strokeStyle = "rgba(239,68,68,1)";
    ctx.lineWidth   = 3.4;
    ctx.beginPath();
    ctx.arc(px,py,pzConfig.radius,0,Math.PI*2);
    ctx.stroke();
  }

  // poles
  for (const p of state.poles) {
    const {px,py} = pzToCanvas(p.re,p.im);
    ctx.strokeStyle = "rgba(34,197,94,1)";
    ctx.lineWidth = 3.4;
    const r = pzConfig.radius;
    ctx.beginPath();
    ctx.moveTo(px-r,py-r); ctx.lineTo(px+r,py+r);
    ctx.moveTo(px-r,py+r); ctx.lineTo(px+r,py-r);
    ctx.stroke();
  }

  ctx.restore();
}

/* ============================
   PZ interaction
   ============================ */

let dragInfo = null;

function findNearestElement(px, py, maxPxDist = 12) {
  const threshold2 = maxPxDist*maxPxDist;
  let best = null;

  function test(list, type) {
    for (let i = 0; i < list.length; i++) {
      const {px: cx, py: cy} = pzToCanvas(list[i].re, list[i].im);
      const dx = cx - px, dy = cy - py;
      const d2 = dx*dx + dy*dy;
      if (d2 <= threshold2 && (!best || d2 < best.dist2)) {
        best = {type, index: i, dist2: d2};
      }
    }
  }

  test(state.zeros, "zero");
  test(state.poles, "pole");
  return best;
}

pzCanvas.addEventListener("mousedown", e => {
  const rect = pzCanvas.getBoundingClientRect();
  const cssPx = e.clientX - rect.left;
  const cssPy = e.clientY - rect.top;

  const hit = findNearestElement(cssPx, cssPy, 12);
  if (!hit) return;

  const list = (hit.type === "zero") ? state.zeros : state.poles;
  const elem = list[hit.index];
  let conjIndex = null;
  if (Math.abs(elem.im) > 1e-8) {
    for (let i = 0; i < list.length; i++) {
      if (i === hit.index) continue;
      if (Math.abs(list[i].re - elem.re) < 1e-6 &&
          Math.abs(list[i].im + elem.im) < 1e-6) {
        conjIndex = i;
        break;
      }
    }
  }
  dragInfo = { type: hit.type, index: hit.index, conjIndex };
  e.preventDefault();
});

pzCanvas.addEventListener("mousemove", e => {
  if (!dragInfo) return;
  const rect = pzCanvas.getBoundingClientRect();
  const cssPx = e.clientX - rect.left;
  const cssPy = e.clientY - rect.top;
  const world = canvasToPZ(cssPx, cssPy);
  const list = dragInfo.type === "zero" ? state.zeros : state.poles;
  const main = list[dragInfo.index];

  const startedReal = Math.abs(main.im) < 1e-8 && dragInfo.conjIndex == null;

  if (startedReal) {
    main.re = world.re;
    main.im = 0;
  } else {
    main.re = world.re;
    main.im = world.im;
    if (dragInfo.conjIndex != null) {
      const conj = list[dragInfo.conjIndex];
      conj.re = world.re;
      conj.im = -world.im;
    }
  }

  drawPZ();
  updateTextFromPZ();
  scheduleUpdate();
});

pzCanvas.addEventListener("mouseup", () => dragInfo = null);
pzCanvas.addEventListener("mouseleave", () => dragInfo = null);

pzCanvas.addEventListener("dblclick", e => {
  const rect = pzCanvas.getBoundingClientRect();
  const cssPx = e.clientX - rect.left;
  const cssPy = e.clientY - rect.top;

  const hit = findNearestElement(cssPx, cssPy, 10);
  if (hit) {
    const list = hit.type === "zero" ? state.zeros : state.poles;
    const elem = list[hit.index];
    if (Math.abs(elem.im) > 1e-8) {
      for (let i = list.length - 1; i >= 0; i--) {
        if (Math.abs(list[i].re - elem.re) < 1e-6 &&
            Math.abs(list[i].im + elem.im) < 1e-6) {
          list.splice(i, 1);
        }
      }
    }
    list.splice(hit.index, 1);
    drawPZ();
    updateTextFromPZ();
    scheduleUpdate();
    return;
  }

  const {re, im} = canvasToPZ(cssPx, cssPy);
  const addType = [...addTypeRadios].find(r => r.checked)?.value || "pole";

  const realAxis = pzToCanvas(0, 0).py;
  const dy = Math.abs(cssPy - realAxis);
  const nearReal = dy <= 10;

  if (nearReal) {
    if (addType === "zero") {
      state.zeros.push({re: re, im: 0});
    } else {
      state.poles.push({re: re, im: 0});
    }
  } else {
    const imag = Math.abs(im); // ensure positive imag in internal representation
    if (addType === "zero") {
      state.zeros.push({re, im: imag});
      state.zeros.push({re, im: -imag});
    } else {
      state.poles.push({re, im: imag});
      state.poles.push({re, im: -imag});
    }
  }

  drawPZ();
  updateTextFromPZ();
  scheduleUpdate();
});

/* ============================
   Text <-> PZ parsing (Im ≥ 0 only in text)
   ============================ */

function parseComplexList(str) {
  const out = [];
  if (!str.trim()) return out;
  const parts = str.split(",");
  for (let p of parts) {
    p = p.trim();
    if (!p) continue;
    let re = 0, im = 0;
    const m = p.match(/^([+-]?[0-9]*\.?[0-9]+)?([+-][0-9]*\.?[0-9]+)?[ij]?$/i);
    if (m) {
      if (m[1]) re = parseFloat(m[1]);
      if (m[2]) im = parseFloat(m[2]);
    } else {
      const v = Number(p);
      if (!Number.isNaN(v)) re = v;
    }
    if (im < 0) im = -im; // enforce Im ≥ 0 for text
    out.push({re, im});
  }
  return out;
}

/* Given list where each entry has Im ≥ 0, create full set with conjugates.
   Also, when user edits one complex root, we keep its conjugate consistent. */
function ensureConjugatePairsFromUpper(list) {
  const result = [];
  for (const z of list) {
    if (Math.abs(z.im) < 1e-8) {
      result.push({re: z.re, im: 0});
    } else {
      result.push({re: z.re, im: z.im});
      result.push({re: z.re, im: -z.im});
    }
  }
  return result;
}

function formatUpperHalfListFromFull(list) {
  // Build map keyed by (re, |im|) and keep Im ≥ 0
  const seen = [];
  for (const z of list) {
    const re = z.re;
    const imAbs = Math.abs(z.im);
    let found = false;
    for (const e of seen) {
      if (Math.abs(e.re - re) < 1e-6 && Math.abs(e.im - imAbs) < 1e-6) {
        found = true;
        break;
      }
    }
    if (!found) {
      seen.push({re, im: imAbs});
    }
  }
  return seen.map(z => {
    if (Math.abs(z.im) < 1e-9) return fmt(z.re,4);
    return `${fmt(z.re,4)}+${fmt(z.im,4)}j`;
  }).join(", ");
}

function updateTextFromPZ() {
  zerosInput.value = formatUpperHalfListFromFull(state.zeros);
  polesInput.value = formatUpperHalfListFromFull(state.poles);
}

function applyZerosFromText() {
  const upper = parseComplexList(zerosInput.value);
  state.zeros = ensureConjugatePairsFromUpper(upper);
  zerosInput.value = formatUpperHalfListFromFull(state.zeros);
}
function applyPolesFromText() {
  const upper = parseComplexList(polesInput.value);
  state.poles = ensureConjugatePairsFromUpper(upper);
  polesInput.value = formatUpperHalfListFromFull(state.poles);
}

/* ============================
   Main update / simulation
   ============================ */

let pending = false;
function scheduleUpdate() {
  if (pending) return;
  pending = true;
  requestAnimationFrame(() => { pending = false; updateAll(); });
}

function validate() {
  const problems = [];
  if (!(state.tMax > 0)) problems.push("tMax must be > 0.");
  if (!(state.dt > 0)) problems.push("dt must be > 0.");
  if (state.dt > state.tMax) problems.push("Use dt ≤ tMax.");
  if (!isFiniteNumber(state.K)) problems.push("Gain K must be finite.");
  if (!(state.pzAxis.reMax > state.pzAxis.reMin)) problems.push("Re max must be > Re min.");
  if (!(state.pzAxis.imMax > 0)) problems.push("|Im max| must be > 0.");

  // Unstable only if a POLE has Re > 0
  let unstable = false;
  for (const p of state.poles) if (p.re > 0) { unstable = true; break; }
  return { problems, unstable };
}

function updateAll() {
  state.tMax = Number(tMaxInput.value) || state.tMax;
  state.dt   = Number(dtInput.value)   || state.dt;
  state.K    = Number(gainInput.value) || state.K;
  state.showFinalValue     = !!showFinalValueCheckbox.checked;
  state.showResponsePlot   = !!showResponsePlotCheckbox.checked;
  state.showResponseCurve  = !!showResponseCurveCheckbox.checked;

  // Keep response area in layout; hide visually only
  responseWrapper.style.visibility = state.showResponsePlot ? "visible" : "hidden";

  if (!state.showResponsePlot) {
    const ctx = responseCanvas.getContext("2d");
    const dpr = window.devicePixelRatio || 1;
    const w = responseCanvas.width / dpr;
    const h = responseCanvas.height / dpr;
    ctx.save();
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, w, h);
    ctx.restore();
  }

  state.pzAxis.reMin = Number(reMinInput.value) || state.pzAxis.reMin;
  state.pzAxis.reMax = Number(reMaxInput.value) || state.pzAxis.reMax;
  state.pzAxis.imMax = Math.abs(Number(imMaxInput.value) || state.pzAxis.imMax);
  imMinDisplay.value = "-" + fmt(state.pzAxis.imMax,4);

  const {problems, unstable} = validate();
  if (problems.length) {
    simStatus.innerHTML = `<span class="err">${problems.join(" ")}</span>`;
  } else if (unstable) {
    simStatus.innerHTML = `<span class="warn">System has poles with Re > 0 (unstable).</span>`;
  } else {
    simStatus.innerHTML = `<span class="ok">Simulation OK.</span>`;
  }

  drawPZ();

  const tf = buildTransferFunction(state.zeros, state.poles, state.K);
  const ss = tfToStateSpace(tf.num, tf.den);
  const {t, y, r} = simulateSystem(ss, state.tMax, state.dt, state.inputType);

  const yExt = computeMinMax(y);
  let dataMin = yExt.min;
  let dataMax = yExt.max;

  const axisMax = dataMax * 1.05;
  const span    = axisMax - dataMin || 1;
  const padLow  = span * 0.1;
  const axisMin = dataMin - padLow;

  const finalValue = y[y.length - 1];

  if (state.showResponsePlot) {
    plotResponseWithInput(
      responseCanvas, t, y, r,
      state.tMax, axisMin, axisMax,
      {
        showFinal: state.showFinalValue,
        finalValue,
        showCurve: state.showResponseCurve
      }
    );
  }
}

/* ============================
   Wire controls
   ============================ */

inputTypeRadios.forEach(r => {
  r.addEventListener("change", () => {
    if (r.checked) {
      state.inputType = r.value;
      scheduleUpdate();
    }
  });
});

showFinalValueCheckbox.addEventListener("change", scheduleUpdate);
showResponsePlotCheckbox.addEventListener("change", scheduleUpdate);
showResponseCurveCheckbox.addEventListener("change", scheduleUpdate);

tMaxInput.addEventListener("input", scheduleUpdate);
dtInput.addEventListener("input", scheduleUpdate);
gainInput.addEventListener("input", scheduleUpdate);

zerosInput.addEventListener("change", () => {
  applyZerosFromText();
  drawPZ();
  scheduleUpdate();
});
polesInput.addEventListener("change", () => {
  applyPolesFromText();
  drawPZ();
  scheduleUpdate();
});

reMinInput.addEventListener("input", scheduleUpdate);
reMaxInput.addEventListener("input", scheduleUpdate);
imMaxInput.addEventListener("input", scheduleUpdate);

addAtCenterBtn.addEventListener("click", () => {
  const re = (state.pzAxis.reMin + state.pzAxis.reMax)/2;
  const addType = [...addTypeRadios].find(r => r.checked)?.value || "pole";

  if (addType === "zero") {
    state.zeros.push({re, im: 0});
  } else {
    state.poles.push({re, im: 0});
  }
  drawPZ();
  updateTextFromPZ();
  scheduleUpdate();
});

resetSystemBtn.addEventListener("click", () => {
  resetSystem();
  tMaxInput.value = "10.1";
  dtInput.value   = "0.01";
  gainInput.value = "1";
  [...inputTypeRadios].forEach(r => r.checked = (r.value === "step"));
  state.inputType = "step";

  // defaults: plot hidden, curve on, final value off
  showFinalValueCheckbox.checked    = true;
  showResponsePlotCheckbox.checked  = true;
  showResponseCurveCheckbox.checked = true;
  state.showFinalValue    = false;
  state.showResponsePlot  = false;
  state.showResponseCurve = true;
  responseWrapper.style.visibility = "hidden";

  reMinInput.value = "-5";
  reMaxInput.value = "2";
  imMaxInput.value = "3";

  [...addTypeRadios].forEach(r => {
    r.checked = (r.value === "pole");
  });

  updateTextFromPZ();
  scheduleUpdate();
});

/* ============================
   Initialization
   ============================ */

(function init() {
  resetSystem();
  setupCanvas(responseCanvas, 600, 260);
  setupCanvas(pzCanvas,       600, 260);

  [...addTypeRadios].forEach(r => {
    r.checked = (r.value === "pole");
  });

  // Initial checkbox states: plot hidden
  showResponsePlotCheckbox.checked  = false;
  showResponseCurveCheckbox.checked = true;
  showFinalValueCheckbox.checked    = false;
  responseWrapper.style.visibility  = "hidden";

  updateTextFromPZ();
  scheduleUpdate();

  window.addEventListener("resize", () => {
    setupCanvas(responseCanvas, 600, 260);
    setupCanvas(pzCanvas,       600, 260);
    scheduleUpdate();
  });
})();
</script>
</body>
</html>
