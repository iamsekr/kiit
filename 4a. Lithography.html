<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Semiconductor Fab: Dual Layer Process</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --panel-bg: #ffffff;
            --accent: #2563eb;
            --text-main: #333333;
            --border: #e5e7eb;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: var(--text-main);
            display: flex;
            height: 100vh;
        }

        /* --- LEFT SIDE: 3D CANVAS --- */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            background: linear-gradient(to bottom, #ffffff 0%, #f0f2f5 100%);
            cursor: move;
        }

        /* --- RIGHT SIDE: CONTROLS --- */
        #sidebar {
            width: 350px;
            background-color: var(--panel-bg);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 25px;
            box-shadow: -5px 0 20px rgba(0,0,0,0.05);
            z-index: 10;
        }

        h1 { margin: 0 0 5px 0; font-size: 1.4rem; color: var(--accent); font-weight: 700; letter-spacing: 0.5px; }
        h3 { margin: 0 0 20px 0; font-size: 0.9rem; color: #666; font-weight: 400; }

        .step-card {
            background: #f1f5f9;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            min-height: 120px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }
        .step-num { font-size: 0.75rem; text-transform: uppercase; color: #64748b; font-weight: bold; margin-bottom: 6px; display: block;}
        .step-title { font-size: 1.1rem; font-weight: bold; margin-bottom: 10px; color: #1e293b; }
        .step-desc { font-size: 0.9rem; line-height: 1.5; color: #475569; }

        .controls-area {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Slider Styling */
        .slider-group {
            margin-bottom: 10px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            font-weight: 600;
            color: #475569;
            margin-bottom: 8px;
        }
        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent);
        }
        input[type=range]:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .btn-row { display: flex; gap: 10px; }

        button {
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .btn-primary { background-color: var(--accent); color: #fff; box-shadow: 0 4px 6px rgba(37, 99, 235, 0.2); }
        .btn-primary:hover { background-color: #1d4ed8; transform: translateY(-1px); }
        .btn-primary:disabled { background-color: #cbd5e1; color: #94a3b8; cursor: not-allowed; transform: none; box-shadow: none; }

        .btn-secondary { background-color: white; border: 1px solid #cbd5e1; color: #475569; }
        .btn-secondary:hover { background-color: #f8fafc; border-color: #94a3b8; color: #1e293b; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #aaa; font-size: 1.5rem;
        }
        
        #uv-overlay {
            position: absolute; inset: 0;
            background: rgba(138, 43, 226, 0.15);
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 5;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">Initializing...</div>
    <div id="uv-overlay"></div>

    <div id="canvas-container"></div>

    <div id="sidebar">
        <div>
            <h1>Fab Lab: Dual Layer</h1>
            <h3>Vapor Deposition Process</h3>
        </div>

        <div class="step-card">
            <span class="step-num" id="ui-step-num">Intro</span>
            <div class="step-title" id="ui-title">Silicon Substrate</div>
            <div class="step-desc" id="ui-desc">
                The foundation of the chip. A pure crystal silicon wafer.
            </div>
        </div>

        <div class="controls-area">
            <div class="slider-group">
                <div class="slider-label">
                    <span>Mask Height</span>
                    <span id="maskHeightVal">3.5</span>
                </div>
                <input type="range" id="maskHeight" min="1.5" max="8.0" step="0.1" value="3.5" disabled>
            </div>

            <div class="btn-row">
                <button id="backBtn" class="btn-secondary" disabled>← Back</button>
                <button id="nextBtn" class="btn-primary">Next Step →</button>
            </div>
            <button id="resetBtn" class="btn-secondary" style="margin-top:5px; border-color: #fca5a5; color: #b91c1c;">Reset Simulation</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ================= CONFIGURATION =================
        const CONFIG = {
            waferSize: 10,        
            subThickness: 0.8,    
            layerThickness: 0.1,  
            
            // COLORS
            colorSilicon: 0x505050,
            colorOxide: 0xA2D9FF,      
            colorMetal: 0xd4af37,        // Gold/Copper
            colorResistLiquid: 0xFCA5A5, // Pinkish
            colorResistHard: 0xd13f3f,   // Deep Red (Exposed)
            colorResistSoft: 0xFCA5A5,   // Pale Pink (Unexposed)
            colorMaskChrome: 0x111111,

            colorMaskGlass: 0xc2ff78,   // Glass mask
            colorUvLight: 0x8000ff,      
            
            // SETTINGS
            particleCount: 800,    
            uvDuration: 8000 // 8 Seconds
        };
        // =================================================

        const MATS = {
            silicon: new THREE.MeshStandardMaterial({ color: CONFIG.colorSilicon, roughness: 0.4, metalness: 0.1 }),
            oxide: new THREE.MeshStandardMaterial({ color: CONFIG.colorOxide, roughness: 0.6 }), 
            metal: new THREE.MeshStandardMaterial({ color: CONFIG.colorMetal, roughness: 0.2, metalness: 0.9 }), 
            resistLiq: new THREE.MeshStandardMaterial({ color: CONFIG.colorResistLiquid, roughness: 0.2 }), 
            resistHard: new THREE.MeshStandardMaterial({ color: CONFIG.colorResistHard, roughness: 0.3 }), 
            resistSoft: new THREE.MeshStandardMaterial({ color: CONFIG.colorResistSoft, roughness: 0.3 }), 
            maskChrome: new THREE.MeshStandardMaterial({ color: CONFIG.colorMaskChrome, roughness: 0.1, metalness: 0.5 }), 
            maskGlass: new THREE.MeshPhysicalMaterial({ color: CONFIG.colorMaskGlass, transmission: 0.98, opacity: 0.3, transparent: true, thickness: 0.5, roughness: 0 }),
            bulb: new THREE.MeshStandardMaterial({ color: 0xaa00ff, emissive: 0xaa00ff, emissiveIntensity: 1 })
        };

        const scene = new THREE.Scene();
        const bgCol = 0x787777;
        scene.background = new THREE.Color(bgCol); 
        scene.fog = new THREE.Fog(bgCol, 20, 60);

        const container = document.getElementById('canvas-container');
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(12, 14, 14);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.SoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minPolarAngle = 0; 
        controls.maxPolarAngle = Math.PI; 

        const ambi = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambi);
        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(5, 10, 5);
        dir.castShadow = true;
        dir.shadow.mapSize.width = 2048;
        dir.shadow.mapSize.height = 2048;
        scene.add(dir);

        document.getElementById('loading').style.display = 'none';

        // --- GLOBAL STATE FOR MASK HEIGHT ---
        let currentMaskHeight = 3.5;

        // --- LAYER 1 PATTERN (Base Traces) ---
        const PATTERN_1 = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,1,1,0,0,0,0,0,0,0,1,1,0], 
            [0,1,1,0,0,0,0,0,0,0,1,1,0],
            [0,0,1,0,0,0,0,0,0,0,1,0,0],
            [0,0,1,1,1,1,0,1,1,1,1,0,0], 
            [0,0,0,0,0,1,0,1,0,0,0,0,0],
            [0,0,0,0,0,1,1,1,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,0,0,0], 
            [0,0,1,0,0,0,0,0,0,1,0,0,0],
            [0,0,1,0,0,0,0,0,0,1,0,0,0],
            [0,1,1,0,0,0,0,0,0,1,1,0,0], 
            [0,0,0,0,0,0,0,0,0,0,0,0,0]
        ];

        // --- LAYER 2 PATTERN (Complex Interconnects) ---
        const PATTERN_2 = [
            [1,0,1,0,0,0,1,0,0,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,0,1,0,1], 
            [1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,1,0,1,0,1,0,0,0,1],
            [1,1,1,1,1,0,1,0,1,1,1,1,1], 
            [0,0,1,0,0,0,1,0,0,0,1,0,0],
            [1,1,1,0,1,1,0,1,1,0,1,1,1], // Dense Center
            [0,0,1,0,0,0,1,0,0,0,1,0,0],
            [1,1,1,1,1,0,1,0,1,1,1,1,1], 
            [1,0,0,0,1,0,1,0,1,0,0,0,1],
            [1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,0,1,0,1], 
            [1,0,1,0,0,0,1,0,0,0,1,0,1]
        ];

        const GRID_SIZE = 13;
        const CELL_SIZE = CONFIG.waferSize / GRID_SIZE; 
        const WAFER_SIZE = CONFIG.waferSize;
        const MESH_IDS = { FIELD: 0, TRACE: 1 };

        // --- WORLD CONTAINER ---
        const world = new THREE.Group();
        world.position.y = -2;
        scene.add(world);
        
        // --- GEOMETRY FACTORY ---
        function createPatternedLayer(material, yStart, thickness, patternArray) {
            const group = new THREE.Group();
            group.position.y = yStart; 
            
            const offset = WAFER_SIZE / 2 - (CELL_SIZE/2);
            
            for(let r=0; r<GRID_SIZE; r++){
                for(let c=0; c<GRID_SIZE; c++){
                    const isTrace = patternArray[r][c] === 1;
                    const type = isTrace ? MESH_IDS.TRACE : MESH_IDS.FIELD;
                    
                    const geo = new THREE.BoxGeometry(CELL_SIZE, thickness, CELL_SIZE);
                    geo.translate(0, thickness/2, 0); 
                    
                    const mat = material.clone();
                    const mesh = new THREE.Mesh(geo, mat);
                    
                    mesh.position.set(
                        c * CELL_SIZE - offset,
                        0, 
                        r * CELL_SIZE - offset
                    );
                    
                    mesh.userData = { type: type };
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    group.add(mesh);
                }
            }
            return group;
        }

        let pulseInterval = null;
        let colorTweenInterval = null;

        const ctx = {
            add: (obj) => world.add(obj),
            
            animateVaporDeposition: (obj, color, thickness, duration = 3000) => {
                obj.scale.y = 0.001;
                obj.visible = true;
                const growthStep = 16 / duration; 

                const rainGroup = new THREE.Group();
                world.add(rainGroup);
                const geo = new THREE.BoxGeometry(0.06, 0.06, 0.06);
                const mat = new THREE.MeshBasicMaterial({color: color});

                const rainInterval = setInterval(() => {
                   if(obj.scale.y >= 1) {
                       clearInterval(rainInterval);
                       setTimeout(() => { world.remove(rainGroup); }, 500);
                       return;
                   }
                   for(let i=0; i<8; i++) { 
                       const p = new THREE.Mesh(geo, mat);
                       p.position.set(
                           (Math.random()-0.5) * WAFER_SIZE, 
                           obj.position.y + 6, 
                           (Math.random()-0.5) * WAFER_SIZE
                       );
                       rainGroup.add(p);
                       let speed = 0.4;
                       const fall = setInterval(() => {
                           p.position.y -= speed;
                           const currentSurfaceY = obj.position.y + (thickness * obj.scale.y);
                           if(p.position.y <= currentSurfaceY) {
                               rainGroup.remove(p);
                               clearInterval(fall);
                           }
                       }, 16);
                   }
                }, 40);

                let s = 0;
                const grow = setInterval(() => {
                    s += growthStep; 
                    obj.scale.y = s;
                    if(s >= 1) { 
                        obj.scale.y = 1; 
                        clearInterval(grow); 
                    }
                }, 16);
            },
            
            animateRemovalParticles: (color, yBase) => {
                const count = CONFIG.particleCount;
                const geo = new THREE.BoxGeometry(0.08, 0.08, 0.08);
                const mat = new THREE.MeshBasicMaterial({color: color});
                for(let i=0; i<count; i++) {
                    const p = new THREE.Mesh(geo, mat);
                    p.position.set((Math.random()-0.5)*WAFER_SIZE, yBase, (Math.random()-0.5)*WAFER_SIZE);
                    world.add(p);
                    let speed = 0.05 + Math.random()*0.1;
                    const fly = setInterval(()=>{
                        p.position.y += speed;
                        p.position.x += (Math.random()-0.5)*0.1;
                        p.position.z += (Math.random()-0.5)*0.1;
                        if(p.position.y > yBase + 4) {
                            world.remove(p);
                            clearInterval(fly);
                        }
                    }, 16);
                }
            },
            
            animateShrink: (obj) => {
                let s = 1;
                const i = setInterval(()=>{
                    s-=0.05;
                    obj.scale.y = s;
                    if(s<=0) { obj.visible=false; clearInterval(i); }
                }, 16);
            },
            
            animateMove: (obj, targetY) => {
                let steps = 0;
                const startY = obj.position.y;
                const i = setInterval(()=>{
                    steps+=0.05;
                    obj.position.y = startY + (targetY - startY) * steps;
                    if(steps>=1) clearInterval(i);
                }, 16);
            }
        };

        const STEPS = [
            {
                title: "Silicon Substrate",
                desc: "Foundation: Pure Crystal Silicon (P-Type).",
                render: (c, instant) => {
                    const baseGeo = new THREE.BoxGeometry(WAFER_SIZE, CONFIG.subThickness, WAFER_SIZE);
                    baseGeo.translate(0, CONFIG.subThickness/2, 0); 
                    const sub = new THREE.Mesh(baseGeo, MATS.silicon);
                    sub.position.y = 0;
                    c.add(sub);
                }
            },
            {
                title: "Oxidation (Layer 1)",
                desc: "Silicon Dioxide (Blue) is deposited from the gas phase onto the substrate.",
                render: (c, instant) => {
                    const yPos = CONFIG.subThickness; 
                    const ox = createPatternedLayer(MATS.oxide, yPos, CONFIG.layerThickness, PATTERN_1);
                    ox.name = "oxide_layer";
                    c.add(ox);
                    if(instant) ox.scale.y = 1;
                    else c.animateVaporDeposition(ox, CONFIG.colorOxide, CONFIG.layerThickness, 2000); 
                }
            },
            {
                title: "Photoresist (Layer 1)",
                desc: "Negative Photoresist (Pink) is deposited via Vapor Deposition.",
                render: (c, instant) => {
                    const yPos = CONFIG.subThickness + CONFIG.layerThickness; 
                    const res = createPatternedLayer(MATS.resistLiq, yPos, CONFIG.layerThickness, PATTERN_1);
                    res.name = "resist_layer";
                    c.add(res);
                    if(instant) res.scale.y = 1;
                    else c.animateVaporDeposition(res, CONFIG.colorResistLiquid, CONFIG.layerThickness, 1000); 
                }
            },
            {
                title: "Mask 1 Alignment",
                desc: "The Circuit Mask is aligned.",
                render: (c, instant) => {
                    const maskGroup = new THREE.Group();
                    maskGroup.name = "mask_group";
                    const glass = new THREE.Mesh(new THREE.BoxGeometry(WAFER_SIZE, 0.1, WAFER_SIZE), MATS.maskGlass);
                    maskGroup.add(glass);
                    const offset = (GRID_SIZE * CELL_SIZE) / 2 - (CELL_SIZE/2);
                    for(let r=0; r<GRID_SIZE; r++){
                        for(let cIdx=0; cIdx<GRID_SIZE; cIdx++){
                            if(PATTERN_1[r][cIdx] === 1) {
                                const chrome = new THREE.Mesh(new THREE.BoxGeometry(CELL_SIZE, 0.12, CELL_SIZE), MATS.maskChrome);
                                chrome.position.set(cIdx * CELL_SIZE - offset, 0, r * CELL_SIZE - offset);
                                maskGroup.add(chrome);
                            }
                        }
                    }
                    c.add(maskGroup);
                    
                    if(instant) maskGroup.position.set(0, currentMaskHeight, 0);
                    else {
                        maskGroup.position.set(0, currentMaskHeight + 1.5, 0); 
                        c.animateMove(maskGroup, currentMaskHeight);
                    }
                }
            },
            {
                title: "UV Exposure 1",
                desc: "Exposure hardens resist (Deep Red) where mask allows light.",
                render: (c, instant) => {
                    const bulbGroup = new THREE.Group();
                    bulbGroup.name = "uv_bulb";
                    const rollerGeo = new THREE.CylinderGeometry(0.5, 0.5, WAFER_SIZE + 2, 32);
                    rollerGeo.rotateZ(Math.PI/2);
                    bulbGroup.add(new THREE.Mesh(rollerGeo, MATS.bulb));
                    const light = new THREE.PointLight(CONFIG.colorUvLight, 0, 40);
                    light.position.y = -2;
                    bulbGroup.add(light);
                    bulbGroup.position.set(0, 8, 0);
                    c.add(bulbGroup);

                    const overlay = document.getElementById('uv-overlay');

                    if(instant) {
                        light.intensity = 5;
                        overlay.style.opacity = 0.8;
                        const r = world.getObjectByName("resist_layer");
                        if(r) r.children.forEach(b => {
                            b.material.color.setHex((b.userData.type===MESH_IDS.FIELD) ? CONFIG.colorResistHard : CONFIG.colorResistSoft);
                        });
                    } else {
                        setTimeout(() => {
                            light.intensity = 5;
                            overlay.style.opacity = 1;
                            
                            const startTime = Date.now();
                            const resLayer = world.getObjectByName("resist_layer");
                            const startColor = new THREE.Color(CONFIG.colorResistSoft);
                            const endColor = new THREE.Color(CONFIG.colorResistHard);

                            if(colorTweenInterval) clearInterval(colorTweenInterval);
                            colorTweenInterval = setInterval(() => {
                                const elapsed = Date.now() - startTime;
                                let progress = elapsed / 2000; 
                                if(progress > 1) progress = 1;
                                if(resLayer) {
                                    resLayer.children.forEach(block => {
                                        if(block.userData.type === MESH_IDS.FIELD) {
                                            block.material.color.lerpColors(startColor, endColor, progress);
                                        }
                                    });
                                }
                                if(progress >= 1) clearInterval(colorTweenInterval);
                            }, 50);
                        }, 500);
                    }
                }
            },
            {
                title: "Inspection 1",
                desc: "Mask and UV removed.",
                render: (c, instant) => {
                    if(colorTweenInterval) clearInterval(colorTweenInterval);
                    document.getElementById('uv-overlay').style.opacity = 0;
                    const b = world.getObjectByName("uv_bulb"); if(b) b.visible = false;
                    const m = world.getObjectByName("mask_group"); if(m) m.visible = false;
                    const r = world.getObjectByName("resist_layer");
                    if(r) r.children.forEach(b => {
                        b.material.color.setHex((b.userData.type===MESH_IDS.FIELD) ? CONFIG.colorResistHard : CONFIG.colorResistSoft);
                    });
                }
            },
            {
                title: "Development 1",
                desc: "Removing soft resist.",
                render: (c, instant) => {
                    const resLayer = world.getObjectByName("resist_layer");
                    if(instant) {
                        if(resLayer) resLayer.children.forEach(b => { if(b.userData.type === MESH_IDS.TRACE) b.visible=false; });
                    } else {
                        // CHANGE 1: Use resist soft color
                        c.animateRemovalParticles(CONFIG.colorResistSoft, CONFIG.subThickness + CONFIG.layerThickness * 2);
                        if(resLayer) resLayer.children.forEach(b => { if(b.userData.type === MESH_IDS.TRACE) c.animateShrink(b); });
                    }
                }
            },
            {
                title: "Etching 1",
                desc: "Etching exposed Oxide.",
                render: (c, instant) => {
                    const oxLayer = world.getObjectByName("oxide_layer");
                    if(instant) {
                         if(oxLayer) oxLayer.children.forEach(b => { if(b.userData.type === MESH_IDS.TRACE) b.visible=false; });
                    } else {
                        // CHANGE 2: Use Oxide color
                        c.animateRemovalParticles(CONFIG.colorOxide, CONFIG.subThickness + CONFIG.layerThickness);
                        if(oxLayer) oxLayer.children.forEach(b => { if(b.userData.type === MESH_IDS.TRACE) c.animateShrink(b); });
                    }
                }
            },
            {
                title: "Stripping 1",
                desc: "Removing remaining resist.",
                render: (c, instant) => {
                    const resLayer = world.getObjectByName("resist_layer");
                    if(instant) {
                        if(resLayer) resLayer.visible = false;
                    } else {
                        if(resLayer) resLayer.children.forEach(b => { if(b.visible) c.animateShrink(b); });
                    }
                }
            },
            {
                title: "Metal Deposition (Layer 2)",
                desc: "Conductive Metal (Gold/Copper) deposited to form interconnects.",
                render: (c, instant) => {
                    const yPos = CONFIG.subThickness + CONFIG.layerThickness; 
                    const met = createPatternedLayer(MATS.metal, yPos, CONFIG.layerThickness, PATTERN_2);
                    met.name = "metal_layer";
                    c.add(met);
                    if(instant) met.scale.y = 1;
                    else c.animateVaporDeposition(met, CONFIG.colorMetal, CONFIG.layerThickness, 2000); 
                }
            },
            {
                title: "Photoresist (Layer 2)",
                desc: "Second layer of photoresist applied.",
                render: (c, instant) => {
                    const yPos = CONFIG.subThickness + CONFIG.layerThickness * 2; 
                    const res = createPatternedLayer(MATS.resistLiq, yPos, CONFIG.layerThickness, PATTERN_2);
                    res.name = "resist_layer_2";
                    c.add(res);
                    if(instant) res.scale.y = 1;
                    else c.animateVaporDeposition(res, CONFIG.colorResistLiquid, CONFIG.layerThickness, 1000); 
                }
            },
            {
                title: "Mask 2 Alignment",
                desc: "Complex interconnect mask aligned.",
                render: (c, instant) => {
                    const maskGroup = new THREE.Group();
                    maskGroup.name = "mask_group_2";
                    const glass = new THREE.Mesh(new THREE.BoxGeometry(WAFER_SIZE, 0.1, WAFER_SIZE), MATS.maskGlass);
                    maskGroup.add(glass);
                    const offset = (GRID_SIZE * CELL_SIZE) / 2 - (CELL_SIZE/2);
                    for(let r=0; r<GRID_SIZE; r++){
                        for(let cIdx=0; cIdx<GRID_SIZE; cIdx++){
                            if(PATTERN_2[r][cIdx] === 1) {
                                const chrome = new THREE.Mesh(new THREE.BoxGeometry(CELL_SIZE, 0.12, CELL_SIZE), MATS.maskChrome);
                                chrome.position.set(cIdx * CELL_SIZE - offset, 0, r * CELL_SIZE - offset);
                                maskGroup.add(chrome);
                            }
                        }
                    }
                    c.add(maskGroup);
                    
                    if(instant) maskGroup.position.set(0, currentMaskHeight, 0);
                    else {
                        maskGroup.position.set(0, currentMaskHeight + 1.5, 0);
                        c.animateMove(maskGroup, currentMaskHeight);
                    }
                }
            },
            {
                title: "UV Exposure 2",
                desc: "Exposing second layer pattern.",
                render: (c, instant) => {
                    const bulbGroup = new THREE.Group();
                    bulbGroup.name = "uv_bulb_2";
                    const rollerGeo = new THREE.CylinderGeometry(0.5, 0.5, WAFER_SIZE + 2, 32);
                    rollerGeo.rotateZ(Math.PI/2);
                    bulbGroup.add(new THREE.Mesh(rollerGeo, MATS.bulb));
                    const light = new THREE.PointLight(CONFIG.colorUvLight, 0, 40);
                    light.position.y = -2;
                    bulbGroup.add(light);
                    bulbGroup.position.set(0, 6, 0);
                    c.add(bulbGroup);
                    
                    const overlay = document.getElementById('uv-overlay');

                    if(instant) {
                        light.intensity = 5;
                        overlay.style.opacity = 0.8;
                        const r = world.getObjectByName("resist_layer_2");
                        if(r) r.children.forEach(b => {
                            b.material.color.setHex((b.userData.type===MESH_IDS.FIELD) ? CONFIG.colorResistHard : CONFIG.colorResistSoft);
                        });
                    } else {
                        setTimeout(() => {
                            light.intensity = 5;
                            overlay.style.opacity = 1;
                            const startTime = Date.now();
                            const resLayer = world.getObjectByName("resist_layer_2");
                            const startColor = new THREE.Color(CONFIG.colorResistSoft);
                            const endColor = new THREE.Color(CONFIG.colorResistHard);

                            if(colorTweenInterval) clearInterval(colorTweenInterval);
                            colorTweenInterval = setInterval(() => {
                                const elapsed = Date.now() - startTime;
                                let progress = elapsed / 2000;
                                if(progress > 1) progress = 1;
                                if(resLayer) {
                                    resLayer.children.forEach(block => {
                                        if(block.userData.type === MESH_IDS.FIELD) {
                                            block.material.color.lerpColors(startColor, endColor, progress);
                                        }
                                    });
                                }
                                if(progress >= 1) clearInterval(colorTweenInterval);
                            }, 50);
                        }, 500);
                    }
                }
            },
            {
                title: "Inspection 2",
                desc: "Mask and Light removed.",
                render: (c, instant) => {
                    if(colorTweenInterval) clearInterval(colorTweenInterval);
                    document.getElementById('uv-overlay').style.opacity = 0;
                    const b = world.getObjectByName("uv_bulb_2"); if(b) b.visible = false;
                    const m = world.getObjectByName("mask_group_2"); if(m) m.visible = false;
                    const r = world.getObjectByName("resist_layer_2");
                    if(r) r.children.forEach(b => {
                        b.material.color.setHex((b.userData.type===MESH_IDS.FIELD) ? CONFIG.colorResistHard : CONFIG.colorResistSoft);
                    });
                }
            },
            {
                title: "Development 2",
                desc: "Removing soft resist from Layer 2.",
                render: (c, instant) => {
                    const resLayer = world.getObjectByName("resist_layer_2");
                    if(instant) {
                        if(resLayer) resLayer.children.forEach(b => { if(b.userData.type === MESH_IDS.TRACE) b.visible=false; });
                    } else {
                        // CHANGE 3: Use resist soft color
                        c.animateRemovalParticles(CONFIG.colorResistSoft, CONFIG.subThickness + CONFIG.layerThickness * 3);
                        if(resLayer) resLayer.children.forEach(b => { if(b.userData.type === MESH_IDS.TRACE) c.animateShrink(b); });
                    }
                }
            },
            {
                title: "Etching 2",
                desc: "Etching exposed Metal to create wires.",
                render: (c, instant) => {
                    const metLayer = world.getObjectByName("metal_layer");
                    if(instant) {
                         if(metLayer) metLayer.children.forEach(b => { if(b.userData.type === MESH_IDS.TRACE) b.visible=false; });
                    } else {
                        // CHANGE 4: Use Metal color (Gold/Copper)
                        c.animateRemovalParticles(CONFIG.colorMetal, CONFIG.subThickness + CONFIG.layerThickness * 2);
                        if(metLayer) metLayer.children.forEach(b => { if(b.userData.type === MESH_IDS.TRACE) c.animateShrink(b); });
                    }
                }
            },
            {
                title: "Stripping 2 (Finished)",
                desc: "Removing Resist 2. Dual-layer circuit complete.",
                render: (c, instant) => {
                    const resLayer = world.getObjectByName("resist_layer_2");
                    if(instant) {
                        if(resLayer) resLayer.visible = false;
                    } else {
                        if(resLayer) resLayer.children.forEach(b => { if(b.visible) c.animateShrink(b); });
                    }
                }
            }
        ];

        let currentStepIndex = 0;

        // --- SLIDER LOGIC ---
        const slider = document.getElementById('maskHeight');
        const sliderValDisplay = document.getElementById('maskHeightVal');

        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            sliderValDisplay.innerText = val.toFixed(1);
            
            // 1. UPDATE GLOBAL STATE
            currentMaskHeight = val;

            // 2. APPLY IMMEDIATELY IF VISIBLE
            const m1 = world.getObjectByName("mask_group");
            if(m1 && m1.visible) {
                m1.position.y = val;
            }
            const m2 = world.getObjectByName("mask_group_2");
            if(m2 && m2.visible) {
                m2.position.y = val;
            }
        });

        function renderStep(idx, isBackwards = false) {
            while(world.children.length > 0){ world.remove(world.children[0]); }
            if(pulseInterval) clearInterval(pulseInterval);
            if(colorTweenInterval) clearInterval(colorTweenInterval);
            document.getElementById('uv-overlay').style.opacity = 0;

            for(let i=0; i<=idx; i++) {
                const isCurrent = (i === idx);
                const forceInstant = (!isCurrent) || isBackwards;
                STEPS[i].render(ctx, forceInstant);

                if (forceInstant) {
                    if (STEPS[i].title === "UV Exposure 1") {
                        const r = world.getObjectByName("resist_layer");
                        if(r) r.children.forEach(b => {
                            b.material.color.setHex((b.userData.type===MESH_IDS.FIELD) ? CONFIG.colorResistHard : CONFIG.colorResistSoft);
                        });
                        if (idx > i) { const b = world.getObjectByName("uv_bulb"); if(b) b.visible = false; }
                    }
                    if (STEPS[i].title === "Mask 1 Alignment" && idx >= 5) {
                         const m = world.getObjectByName("mask_group"); if(m) m.visible = false;
                    }
                    if (STEPS[i].title === "Inspection 1") {
                         const b = world.getObjectByName("uv_bulb"); if(b) b.visible = false;
                         const m = world.getObjectByName("mask_group"); if(m) m.visible = false;
                    }
                    if (STEPS[i].title === "UV Exposure 2") {
                        const r = world.getObjectByName("resist_layer_2");
                        if(r) r.children.forEach(b => {
                            b.material.color.setHex((b.userData.type===MESH_IDS.FIELD) ? CONFIG.colorResistHard : CONFIG.colorResistSoft);
                        });
                        if (idx > i) { const b = world.getObjectByName("uv_bulb_2"); if(b) b.visible = false; }
                    }
                    if (STEPS[i].title === "Mask 2 Alignment" && idx >= 14) {
                         const m = world.getObjectByName("mask_group_2"); if(m) m.visible = false;
                    }
                    if (STEPS[i].title === "Inspection 2") {
                         const b = world.getObjectByName("uv_bulb_2"); if(b) b.visible = false;
                         const m = world.getObjectByName("mask_group_2"); if(m) m.visible = false;
                    }
                }
            }

            // --- UPDATE SLIDER UI ---
            slider.value = currentMaskHeight;
            sliderValDisplay.innerText = currentMaskHeight.toFixed(1);

            const m1 = world.getObjectByName("mask_group");
            const m2 = world.getObjectByName("mask_group_2");
            const activeMask = (m1 && m1.visible) ? m1 : ((m2 && m2.visible) ? m2 : null);

            if(activeMask) {
                slider.disabled = false;
            } else {
                slider.disabled = true;
            }

            document.getElementById('ui-step-num').innerText = `Step ${idx+1} / ${STEPS.length}`;
            document.getElementById('ui-title').innerText = STEPS[idx].title;
            document.getElementById('ui-desc').innerHTML = STEPS[idx].desc;

            const btnNext = document.getElementById('nextBtn');
            const btnBack = document.getElementById('backBtn');
            btnBack.disabled = (idx === 0);
            btnNext.disabled = (idx === STEPS.length - 1);
            btnNext.innerText = (idx === STEPS.length - 1) ? "Done" : "Next Step →";
        }

        document.getElementById('nextBtn').addEventListener('click', () => {
            if(currentStepIndex < STEPS.length - 1) {
                currentStepIndex++;
                renderStep(currentStepIndex, false);
            }
        });

        document.getElementById('backBtn').addEventListener('click', () => {
            if(currentStepIndex > 0) {
                currentStepIndex--;
                renderStep(currentStepIndex, true);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            currentStepIndex = 0;
            renderStep(0, false);
        });

        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        renderStep(0);
        animate();
    </script>
</body>
</html>
